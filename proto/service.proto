syntax = "proto3";

package lh_proto;

option go_package = ".;model";
option java_multiple_files = true;
option java_package = "io.littlehorse.common.proto";

import "wf_spec.proto";
import "status.proto";
import "wf_run.proto";
import "variable.proto";
import "external_event.proto";
import "command.proto";

enum LHResponseCodePb {
    OK = 0;
    CONNECTION_ERROR = 1;
    NOT_FOUND_ERROR = 2;
    BAD_REQUEST_ERROR = 3;
    VALIDATION_ERROR = 4;
    ALREADY_EXISTS_ERROR = 5;
    REPORTED_BUT_NOT_PROCESSED = 6;
}

message GetWfSpecPb {
    string name = 1;
    optional int32 version = 2;
}

message GetWfSpecReplyPb {
    LHResponseCodePb code = 1;
    optional string message = 2;
    optional WfSpecPb result = 3;
}

message PutWfSpecReplyPb {
    LHResponseCodePb code = 1;
    optional string message = 2;
    optional WfSpecPb result = 3;
}

message GetTaskDefPb {
    string name = 1;
    optional int32 version = 2;
}

message GetTaskDefReplyPb {
    LHResponseCodePb code = 1;
    optional string message = 2;
    optional TaskDefPb result = 3;
}

message PutTaskDefReplyPb {
    LHResponseCodePb code = 1;
    optional string message = 2;
    optional TaskDefPb result = 3;
}

message PutExternalEventDefReplyPb {
    LHResponseCodePb code = 1;
    optional string message = 2;
    optional ExternalEventDefPb result = 3;    
}

message GetExternalEventDefPb {
    string name = 1;
    optional int32 version = 2;
}

message GetExternalEventDefReplyPb {
    LHResponseCodePb code = 1;
    optional string message = 2;
    optional ExternalEventDefPb result = 3;    
}

message GetWfRunPb {
    string id = 1;
}

message GetWfRunReplyPb {
    LHResponseCodePb code = 1;
    optional string message = 2;
    optional WfRunPb result = 3;
}

message GetNodeRunPb {
    string wf_run_id = 1;
    int32 thread_run_number = 2;
    int32 position = 3;
}

message GetNodeRunReplyPb {
    LHResponseCodePb code = 1;
    optional string message = 2;
    optional NodeRunPb result = 3;
}

message GetVariablePb {
    string wf_run_id = 1;
    string var_name = 2;
    int32 thread_run_number = 3;
}

message GetVariableReplyPb {
    LHResponseCodePb code = 1;
    optional string message = 2;
    optional VariablePb result = 3;
}

message GetExternalEventPb {
    string wf_run_id = 1;
    string external_event_def_name = 2;
    string guid = 3;
}

message GetExternalEventReplyPb {
    LHResponseCodePb code = 1;
    optional string message = 2;
    optional ExternalEventPb result = 3;
}

message PutExternalEventReplyPb {
    LHResponseCodePb code = 1;
    optional string message = 2;
    optional ExternalEventPb result = 3;
}

message RunWfReplyPb {
    LHResponseCodePb code = 1;
    optional string message = 2;
    optional int32 wf_spec_version = 3;
    optional string wf_run_id = 4;
}

message SearchWfRunPb {
    optional bytes bookmark = 1;
    optional int32 limit = 2;

    message StatusAndSpecPb {
        string wf_spec_name = 1;
        LHStatusPb status = 2;
    }
    oneof criteria {
        StatusAndSpecPb status_and_spec = 3;
    }
}

message SearchWfRunReplyPb {
    LHResponseCodePb code = 1;
    optional string message = 2;
    repeated string wf_run_ids = 3;

    // This can optionally be set by whatever backend data store implementation
    // is plugged in. Currently, the only backend implementation is the Kafka
    // Streams backend. In this case, the bytes are a `BookmarkPb`.
    // The client doesn't care what the bytes represent; they just need to provide
    // the raw bytes back on the next request and the backend will take care of it
    // transparently.
    // If the bookmark is null, then it means all results have been returned.
    optional bytes bookmark = 4;
}

message RegisterTaskWorkerPb {
    string client_id = 1;
    string task_def_name = 2;
}

message HostInfoPb {
    string host = 1;
    int32 port = 2;
}

message RegisterTaskWorkerReplyPb {
    LHResponseCodePb code = 1;
    optional string message = 2;
    repeated HostInfoPb endpoints = 3;
}

message PollTaskPb {
    string task_def_name = 1;
    string client_id = 2;
}

message PollTaskReplyPb {
    LHResponseCodePb code = 1;
    optional string message = 2;
    optional TaskScheduleRequestPb result = 3;
}

message ReportTaskReplyPb {
    LHResponseCodePb code = 1;
    optional string message = 2;
}

message StopWfRunReplyPb {
    LHResponseCodePb code = 1;
    optional string message = 2;
}

message ResumeWfRunReplyPb {
    LHResponseCodePb code = 1;
    optional string message = 2;
}

message DeleteWfRunReplyPb {
    LHResponseCodePb code = 1;
    optional string message = 2;
}

message GetMetricsRequestPb {}

message GetMetricsReplyPb {
    string metrics = 1;
}

service LHPublicApi {
    rpc PutTaskDef(PutTaskDefPb) returns (PutTaskDefReplyPb) {}
    rpc GetTaskDef(GetTaskDefPb) returns (GetTaskDefReplyPb) {}

    rpc PutExternalEventDef(PutExternalEventDefPb) returns (PutExternalEventDefReplyPb) {}
    rpc GetExternalEventDef(GetExternalEventDefPb) returns (GetExternalEventDefReplyPb) {}

    rpc PutWfSpec(PutWfSpecPb) returns (PutWfSpecReplyPb) {}
    rpc GetWfSpec(GetWfSpecPb) returns (GetWfSpecReplyPb) {}

    rpc RunWf(RunWfPb) returns (RunWfReplyPb) {}
    rpc GetWfRun(GetWfRunPb) returns (GetWfRunReplyPb) {}

    rpc GetNodeRun(GetNodeRunPb) returns (GetNodeRunReplyPb) {}

    rpc GetVariable(GetVariablePb) returns (GetVariableReplyPb) {}

    rpc PutExternalEvent(PutExternalEventPb) returns (PutExternalEventReplyPb) {}
    rpc GetExternalEvent(GetExternalEventPb) returns (GetExternalEventReplyPb) {}

    rpc SearchWfRun(SearchWfRunPb) returns (SearchWfRunReplyPb) {}

    rpc RegisterTaskWorker(RegisterTaskWorkerPb) returns (RegisterTaskWorkerReplyPb) {}
    rpc PollTask(stream PollTaskPb) returns (stream PollTaskReplyPb) {}
    rpc ReportTask(TaskResultEventPb) returns (ReportTaskReplyPb) {}

    rpc StopWfRun(StopWfRunPb) returns (StopWfRunReplyPb) {}
    rpc ResumeWfRun(ResumeWfRunPb) returns (ResumeWfRunReplyPb) {}
    rpc DeleteWfRun(DeleteWfRunPb) returns (DeleteWfRunReplyPb) {}

    rpc GetMetrics(GetMetricsRequestPb) returns (GetMetricsReplyPb) {}
}


/*

What's the difference between a TaskDef and a TaskQueue?
- TaskDef has a Task Queue?
- But the relationship is 1:1
- TaskDef is a metadata spec
- TaskRun is a run object
- TaskQueue is a collection of TaskRun's with:
  * the same TaskDef AND
  * in the SCHEDULED state

Perhaps we should rename TaskQueue to reflect that it's more of an analytics thing?

Add indexing to the TaskRun so that the PopTaskRequest just does a search

Indexing for TaskRun must be *partially consistent* with the updating of the TaskRun.
 - That means that there can be no repartition events between setting TaskRun
   status and the index.

What is in the index entry Key:

 - Index/
 - Resource Type (eg TaskRun)
 - Resource Tag (list of attributes, eg. "TaskDef: foo", "Status: Pending")
 - Resource Order thing
    - Can be set via interface? Default is to return createdAt()
    - Can (maybe) also include priority (eg. for priority queues)
      - Hard to enforce priority across all instances.
      - When request comes to server A, how do we know that Server B doesn't have a
        higher priority task to execute?
 - Resource Object Id 

What are the key things?
fullStoreKey():
  - Should be internal to the LHStoreWrapper
  - f"{resource_type}/{resource_object_id}"

objectId():
   - All Storeable's must implement this
   - Should it be a string? Or a list?
   - Should it be an interface/subclass?
   - enforce that each component is k8s compliant
   - Want to use it to enable subqueries:
     - eg. find TaskRun's by WfRun

Can we create an "Index" object?

How we find crap:

- By full object id (point lookup)
- Prefix scan on object id (eg. get NodeRun's for WfRun)
- By Alias lookup (distributed alias)
- By Alias lookup (global alias)

interface IndexTag {

    // An example of what this is used for is that a TaskRun may have an
    // IndexTag which stores {taskDefName, status}.

    public List<Pair<String, String>> getTags() {
        return {{"taskDefName", taskDefName}, {"status", status}}
    }

    public 
}

interface DistributedIndexDef<T extends Storable<?>, U extends IndexTag> {

    public IndexTag getTag(T thingToIndex) {
        // This is similar to the getTags() method on GETable...
    }

    public 
}

Types of index:
- Discrete/Hot index
- Even index (eg. some STRING VariableValue's)
- Range index (eg. some INT VariableValue's)

If it lives at the DAO level (not the DAO-Impl level), do we distinguish between
the types of index?
 - Postgres, for example, could just do a lookup
 - Kafka Streams needs to distinguish between the types

Where would we want this Index definition to live?

One idea is to define a "Query" class.
 - All GET requests are just Query's
 - The DAO needs to be able to return a result for each Query
 - This could help remove some copy-pasta from the grpc server

Query Types:
 - Point Lookup
 - Prefix Lookup
 - Evenly Partitioned Index Lookup
 - Hot Index Lookup
 - (Later) Range Lookup

One could argue that "Tags" are an implementation detail for the DAO, not
really a thing.
*/
