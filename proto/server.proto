syntax = "proto3";
package lh_proto;

import "google/protobuf/timestamp.proto";
import "lh_proto.proto";

option go_package = ".;model";
option java_multiple_files = true;
option java_package = "io.littlehorse.common.proto.server";

// This section contains models used by the Server for observability
message WfRunPb {
    // Yeah ok it's similar to WfRunStatePb but hear me out
    string id = 1;
    string wf_spec_id = 2;
    string wf_spec_name = 3;
    LHStatusPb status = 4;

    int64 last_update_offset = 5;

    google.protobuf.Timestamp start_time = 6;
    optional google.protobuf.Timestamp end_time = 7;
    repeated ThreadRunPb thread_runs = 8;
}

message ThreadRunPb {
    string wf_run_id = 1;
    int32 number = 2;

    LHStatusPb status = 3;
    string wf_spec_id = 4;
    string thread_spec_name = 5;
    int32 num_steps = 6;

    google.protobuf.Timestamp start_time = 7;
    optional google.protobuf.Timestamp end_time = 8;
}

message TaskRunPb {
    string wf_run_id = 1;
    int32 thread_run_number = 2;
    int32 position = 3;

    int32 number = 4;
    int32 attempt_number = 5;
    LHStatusPb status = 6;
    optional bytes output = 7;
    optional bytes log_output = 8;

    google.protobuf.Timestamp schedule_time = 9;
    optional google.protobuf.Timestamp start_time = 10;
    optional google.protobuf.Timestamp end_time = 11;

    string wf_spec_id = 12;
    string thread_spec_name = 13;
    string node_name = 14;
    string task_def_id = 15;

    optional TaskResultCodePb result_code = 16;
}


// This section defines some common Util responses used by the server.

enum LHResponseCodePb {
    OK = 0;
    CONNECTION_ERROR = 1;
    NOT_FOUND_ERROR = 2;
    BAD_REQUEST_ERROR = 3;
    VALIDATION_ERROR = 4;
}
message LHResponsePb {
    LHResponseCodePb code = 1;
    optional string id = 2;
    optional string message = 3;
    optional bytes result = 4;
    optional string result_class = 5;
}

enum RequestTypePb {
    POST = 0;
    DELETE = 1;
}

message POSTableRequestPb {
    RequestTypePb type = 1;
    string store_key = 2;
    string request_id = 3;
    optional bytes payload = 4;
}

// NOTE: Maybe later we'll add an Entity output thing that lets the
// world know what was just created, but that's for later.

message RangeResponsePb {
    repeated string ids = 1;
    optional string token = 2;
}

// This section defines internal data structures used for data stores.
enum GETableClassEnumPb {
    TASK_DEF = 0;
    WF_SPEC = 1;
    WF_RUN = 2;
    THREAD_RUN = 3;
    TASK_RUN = 4;
}

message AttributePb {
    string key = 1;
    string val = 2;
}

message IndexKeyPb {
    repeated AttributePb attributes = 1;
    GETableClassEnumPb type = 2;
    google.protobuf.Timestamp created = 3;
}

message IndexValuePb {
    repeated string store_key = 1;
}

message IndexEntryPb {
    IndexKeyPb key = 1;
    string store_key = 2;
}

enum IndexActionEnum {
    CREATE_IDX_ENTRY = 0;
    DELETE_IDX_ENTRY = 1;
}

message IndexEntryActionPb {
    IndexEntryPb entry = 1;
    IndexActionEnum action = 2;
}

message GETableEntryPb {
    bytes entry = 1;
    int32 partition = 2;
    int64 last_updated_offset = 3;
}

message IndexEntriesPb {
    repeated IndexEntryPb entries = 1;
}

// For inter-broker communication, eg queryRemoteBytes.
/*
Possible outcomes:

- Success, found the thing. Here are the bytes
- Queried store appropriately but didn't find bytes.
- Couldn't query store, rebalancing.
- Task has migrated and I am no longer the assignee for that partition key.

"task has migrated" type of response requires that request includes the partition key along with
store key

Also may want to distinguish between querying the active and standby. Do we want to pass in info about
the partition? -> can do that, `KeyQueryMetadata#partition()` is what we want.

On another note, how do we want to do readinessProbes? Options are:

-- Make sure state is RUNNING
This would really lean towards Consistency not Availability for queries. 

-- Just check to see if we can get a store. If so, we're good.
Could lead to a bunch of weirdness if in the PARTITIONS_ASSIGNED state and the current active leader.
Will result in a failure. Then the entrypoint caller will have to realize that it failed, then
call standby's. But that shouldn't be too hard.

-- Just make sure we're not in PENDING_ERROR or something like that.
This allows for maximum availability in theory. Depending on the state of each task, the store may
or may not be available. We can surface the info about whether it's running or not via the result.

-----

When forced to query standbys, we can query all of them and return the least-stale result.

Will need to schedule a thread in the background that makes a
call to `streams.allLocalStorePartitionLags()`. It would be best to NOT piggyback the punctuator
because that method takes a long time to return. Probably want to do it every 15 seconds.
*/

enum RemoteStoreQueryStatusPb {
    RSQ_OK = 0;
    RSQ_NOT_FOUND = 1;
    RSQ_MIGRATED = 2;
    RSQ_NOT_AVAILABLE = 3;
}

// message RemoteStoreQueryRequestPb {
//     string store_name = 1;
//     int32 partition = 2;
//     string store_key = 3;
//     bool is_active_store = 4;
// }

message RemoteStoreQueryResponsePb {
    RemoteStoreQueryStatusPb code = 1;
    optional bytes result = 2;
    int64 approximate_lag = 3;
}
