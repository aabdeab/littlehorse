// Timer-related stuff
syntax = "proto3";
package lh_proto;

option go_package = ".;model";
option java_multiple_files = true;
option java_package = "io.littlehorse.common.proto";

import "google/protobuf/timestamp.proto";

// This section contains data structures used internally for sending the results of
// processing Commands. As a refresher, we need to send the result of processing
// over the network because, if Server A receives a request to idempotently run a
// WfRun with id='foo', but id='foo' partition is assigned to Server B, we need
// to do the processing on server B. Therefore, Server A sends the request over
// Kafka to Server B's partition, and then waits for Server B to process the
// request. Server B uses the data structures below to communicate that result
// back to server A.

message CommandResultPb {
    string command_id = 1;
    google.protobuf.Timestamp result_time = 2;
    bytes result = 3;
}

// The section below contains the protocol for inter-broker communication
enum StoreQueryStatusPb {
    RSQ_OK = 0; // If OK and bytes is empty, means that the key is not found.
    RSQ_NOT_AVAILABLE = 2; // Can't query store, eg. during a rebalance or if migrated.
}

message CentralStoreQueryReplyPb {
    StoreQueryStatusPb code = 1;
    optional bytes result = 2;
    int64 approximate_lag = 3;
}

message CentralStoreQueryPb {
    bool enable_stale_stores = 1;
    string full_key = 2;
    optional int32 specific_partition = 3;
}

message WaitForCommandResultPb {
    string command_id = 1;
    int32 specific_partition = 2;
}

message WaitForCommandResultReplyPb {
    StoreQueryStatusPb code = 1;
    optional CommandResultPb result = 2;
    optional string message = 3;
}

service LHInternals {
    rpc CentralStoreQuery(CentralStoreQueryPb) returns (CentralStoreQueryReplyPb) {}
    rpc WaitForCommandResult(WaitForCommandResultPb) returns (WaitForCommandResultReplyPb) {}
}
