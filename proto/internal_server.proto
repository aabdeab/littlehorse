// Timer-related stuff
syntax = "proto3";
package lh_proto;

option go_package = ".;model";
option java_multiple_files = true;
option java_package = "io.littlehorse.common.proto";

import "google/protobuf/timestamp.proto";
import "command.proto";
import "tags.proto";

// The following protobuf definitions are used for paginated responses.
message PartitionBookmarkPb {
    int32 parttion = 1;
    optional string last_key = 2;
}

message BookmarkPb {
    map<int32, PartitionBookmarkPb> in_progress_partitions = 1;
    repeated int32 completed_partitions = 2;
}

// This section contains data structures used internally for sending the results of
// processing Commands. As a refresher, we need to send the result of processing
// over the network because, if Server A receives a request to idempotently run a
// WfRun with id='foo', but id='foo' partition is assigned to Server B, we need
// to do the processing on server B. Therefore, Server A sends the request over
// Kafka to Server B's partition, and then waits for Server B to process the
// request. Server B uses the data structures below to communicate that result
// back to server A.

message CommandResultPb {
    string command_id = 1;
    google.protobuf.Timestamp result_time = 2;
    bytes result = 3;
}

// The section below contains the protocol for inter-broker communication
enum StoreQueryStatusPb {
    RSQ_OK = 0; // If OK and bytes is empty, means that the key is not found.
    RSQ_NOT_AVAILABLE = 2; // Can't query store, eg. during a rebalance or if migrated.
}

message CentralStoreQueryReplyPb {
    StoreQueryStatusPb code = 1;
    optional bytes result = 2;
    int64 approximate_lag = 3;
}

message CentralStoreQueryPb {
    message CentralStoreSubQueryPb {
        oneof query {
            string key = 1;
            string last_from_prefix = 2;
        }
    }
    bool enable_stale_stores = 1;
    optional int32 specific_partition = 2;
    CentralStoreSubQueryPb query = 3;
}

message ProcessCommandPb {
    CommandPb command = 1;
}

message ProcessCommandReplyPb {
    StoreQueryStatusPb code = 1;
    optional CommandResultPb result = 2;
    optional string message = 3;
}

message PaginatedTagQueryPb {
    GETableClassEnumPb object_type = 1;
    repeated AttributePb attributes = 2;
    optional BookmarkPb bookmark = 3;
    int32 limit = 4;
}

message PaginatedTagQueryReplyPb {
    StoreQueryStatusPb code = 1;
    repeated string object_ids = 2;
    BookmarkPb updated_bookmark = 3;
}

// This section is for the internal implementation of the Task Queue.
// It will be optimized and improved in future revisions.
message InternalPollTaskPb {
    string task_queue_name = 1;
}

message InternalPollTaskReplyPb {
    StoreQueryStatusPb code = 1;
    optional TaskScheduleRequestPb result = 2;
}

service LHInternals {
    rpc CentralStoreQuery(CentralStoreQueryPb) returns (CentralStoreQueryReplyPb) {}
    rpc PaginatedTagQuery(PaginatedTagQueryPb) returns (PaginatedTagQueryReplyPb) {}
    
    rpc ProcessCommand(ProcessCommandPb) returns (ProcessCommandReplyPb) {}
    rpc InternalPollTask(InternalPollTaskPb) returns (InternalPollTaskReplyPb) {}
}
